#!/bin/bash

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# ================== 欢迎语 ==================
echo -e "\033[1;35m"
cat <<'WELCOME'
                 _            __             
 _ __ ___   ___ | |__  _   _ / _| __ _ _ __  
| '_ ` _ \ / _ \| '_ \| | | | |_ / _` | '_ \ 
| | | | | | (_) | |_) | |_| |  _| (_| | | | |
|_| |_| |_|\___/|_.__/ \__,_|_|  \__,_|_| |_|

WELCOME
echo -e "\033[0m"
# ============================================


# 函数：安全读取输入（支持回退，不删除提示）
safe_read() {
    local prompt="$1"
    local variable="$2"
    local default_value="$3"
    
    while true; do
        # 使用 read -p 参数来避免换行问题
        if [ -n "$default_value" ]; then
            read -e -p "$(echo -e "${YELLOW}${prompt} [默认: ${default_value}]: ${NC}")" input_value
            # 如果用户只按回车且有默认值，使用默认值
            if [ -z "$input_value" ]; then
                input_value="$default_value"
            fi
        else
            read -e -p "$(echo -e "${YELLOW}${prompt}: ${NC}")" input_value
        fi
        
        # 检查输入是否为空
        if [ -z "$input_value" ]; then
            echo -e "\r${RED}错误: 输入不能为空，请重新输入${NC}"
            continue
        fi
        
        # 检查是否要退出
        if [ "$input_value" = "q" ] || [ "$input_value" = "quit" ] || [ "$input_value" = "exit" ]; then
            echo -e "${YELLOW}退出操作${NC}"
            return 1
        fi
        
        # 将值赋给变量
        eval "$variable=\"$input_value\""
        return 0
    done
}

# 函数：安全读取数字输入
safe_read_number() {
    local prompt="$1"
    local variable="$2"
    local min="$3"
    local max="$4"
    
    while true; do
        # 使用 read -p 参数来避免换行问题
        read -e -p "$(echo -e "${YELLOW}${prompt}: ${NC}")" input_value
        
        # 检查是否要退出
        if [ "$input_value" = "q" ] || [ "$input_value" = "quit" ] || [ "$input_value" = "exit" ]; then
            echo -e "${YELLOW}退出操作${NC}"
            return 1
        fi
        
        # 检查是否为数字
        if ! [[ "$input_value" =~ ^[0-9]+$ ]]; then
            echo -e "\r${RED}错误: 请输入有效的数字${NC}"
            continue
        fi
        
        # 检查范围
        if [ -n "$min" ] && [ "$input_value" -lt "$min" ]; then
            echo -e "\r${RED}错误: 数字不能小于 $min${NC}"
            continue
        fi
        
        if [ -n "$max" ] && [ "$input_value" -gt "$max" ]; then
            echo -e "\r${RED}错误: 数字不能大于 $max${NC}"
            continue
        fi
        
        # 将值赋给变量
        eval "$variable=\"$input_value\""
        return 0
    done
}

# 函数：安全读取确认
safe_read_confirm() {
    local prompt="$1"
    local variable="$2"
    
    while true; do
        # 使用 read -p 参数来避免换行问题
        read -e -p "$(echo -e "${YELLOW}${prompt} [y/N]: ${NC}")" input_value
        
        # 转换为小写
        input_value=$(echo "$input_value" | tr '[:upper:]' '[:lower:]')
        
        # 检查是否要退出
        if [ "$input_value" = "q" ] || [ "$input_value" = "quit" ] || [ "$input_value" = "exit" ]; then
            echo -e "${YELLOW}退出操作${NC}"
            return 1
        fi
        
        # 处理各种确认输入
        case "$input_value" in
            y|yes|Y|YES|是|确认)
                eval "$variable=\"y\""
                return 0
                ;;
            n|no|N|NO|否|取消|"")
                eval "$variable=\"n\""
                return 0
                ;;
            *)
                echo -e "\r${RED}错误: 请输入 y 或 n${NC}"
                ;;
        esac
    done
}

# 函数：获取内网IP地址
get_internal_ip() {
    local ip=""
    # 尝试多种方法获取内网IP
    if command -v hostname >/dev/null 2>&1; then
        ip=$(hostname -I | awk '{print $1}')
    elif command -v ip >/dev/null 2>&1; then
        ip=$(ip route get 1 2>/dev/null | awk '{print $7}' | head -1)
    elif command -v ifconfig >/dev/null 2>&1; then
        ip=$(ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1' | head -1)
    fi
    echo "$ip"
}

# 函数：根据IP确定默认菜单
get_default_menu() {
    local ip=$(get_internal_ip)
    case "$ip" in
        "10.10.10.254") echo "pve" ;;
        "10.10.10.251") echo "fnos" ;;
        "10.10.10.246") echo "nginx" ;;
        *) echo "main" ;;
    esac
}

# 函数：显示主菜单
show_main_menu() {
    clear
    echo -e "${GREEN}"
    echo "========================================"
    echo "         Linux 常用命令工具"
    echo "========================================"
    echo -e "${NC}"
    echo -e "${YELLOW}当前工作目录: $(pwd)${NC}"
    echo -e "${BLUE}内网IP: $(get_internal_ip)${NC}"
    echo "----------------------------------------"
    echo -e "${YELLOW}请选择要使用的命令合集：${NC}"
    echo -e "${CYAN}1. PVE 命令合集${NC}"
    echo -e "${CYAN}2. FnOS 命令合集${NC}"
    echo -e "${CYAN}3. Nginx 命令合集${NC}"
    echo -e "${CYAN}4. Linux 通用命令${NC}"
    echo -e "${CYAN}5. Linux 文件命令${NC}"
    echo -e "${CYAN}6. Linux 压缩/解压${NC}"
    echo -e "${RED}0. 退出脚本${NC}"
    echo "========================================"
}

# 函数：显示PVE子菜单
show_pve_menu() {
    while true; do
        clear
        echo -e "${GREEN}"
        echo "========================================"
        echo "            PVE 命令合集"
        echo "========================================"
        echo -e "${NC}"
        echo -e "${YELLOW}当前工作目录: $(pwd)${NC}"
        echo -e "${BLUE}内网IP: $(get_internal_ip)${NC}"
        echo "----------------------------------------"
        echo -e "${YELLOW}请选择要执行的命令：${NC}"
        echo -e "${BLUE}[虚拟机命令]${NC}"
        echo -e "${CYAN}1. 查看所有虚拟机${NC}"
        echo -e "${CYAN}2. 启动虚拟机${NC}"
        echo -e "${CYAN}3. 关闭虚拟机${NC}"
        echo -e "${BLUE}[LXC容器命令]${NC}"
        echo -e "${CYAN}4. 查看所有容器${NC}"
        echo -e "${CYAN}5. 启动LXC容器${NC}"
        echo -e "${CYAN}6. 关闭LXC容器${NC}"
        echo -e "${RED}0. 返回主菜单${NC}"
        echo "========================================"
        
        if ! safe_read_number "请输入选择" choice 0 6; then
            continue
        fi
        
        case $choice in
            1)
                echo -e "${YELLOW}执行命令: pvesh get /cluster/resources${NC}"
                echo "----------------------------------------"
                pvesh get /cluster/resources
                echo "----------------------------------------"
                ;;
            2)
                if safe_read "请输入要启动的虚拟机ID(多个用空格隔开，输入q退出)" vm_ids; then
                    if [ -n "$vm_ids" ]; then
                        for vm_id in $vm_ids; do
                            echo -e "${YELLOW}启动虚拟机: $vm_id${NC}"
                            qm start $vm_id
                        done
                    else
                        echo -e "${RED}错误: 未输入虚拟机ID${NC}"
                    fi
                fi
                ;;
            3)
                if safe_read "请输入要关闭的虚拟机ID(多个用空格隔开，输入q退出)" vm_ids; then
                    if [ -n "$vm_ids" ]; then
                        for vm_id in $vm_ids; do
                            echo -e "${YELLOW}关闭虚拟机: $vm_id${NC}"
                            qm stop $vm_id
                        done
                    else
                        echo -e "${RED}错误: 未输入虚拟机ID${NC}"
                    fi
                fi
                ;;
            4)
                echo -e "${YELLOW}执行命令: pvesh get /cluster/resources${NC}"
                echo "----------------------------------------"
                pvesh get /cluster/resources
                echo "----------------------------------------"
                ;;
            5)
                if safe_read "请输入要启动的容器ID(多个用空格隔开，输入q退出)" ct_ids; then
                    if [ -n "$ct_ids" ]; then
                        for ct_id in $ct_ids; do
                            echo -e "${YELLOW}启动容器: $ct_id${NC}"
                            lxc-start -n $ct_id
                        done
                    else
                        echo -e "${RED}错误: 未输入容器ID${NC}"
                    fi
                fi
                ;;
            6)
                if safe_read "请输入要关闭的容器ID(多个用空格隔开，输入q退出)" ct_ids; then
                    if [ -n "$ct_ids" ]; then
                        for ct_id in $ct_ids; do
                            echo -e "${YELLOW}关闭容器: $ct_id${NC}"
                            lxc-stop -n $ct_id
                        done
                    else
                        echo -e "${RED}错误: 未输入容器ID${NC}"
                    fi
                fi
                ;;
            0)
                break
                ;;
            *)
                echo -e "${RED}无效的选择，请重新输入${NC}"
                ;;
        esac
        
        echo ""
        echo -e "${YELLOW}按任意键继续...${NC}"
        read -n 1 -s
    done
}

# 函数：显示	FnOS 子菜单
show_fnos_menu() {
    while true; do
        clear
        echo -e "${GREEN}"
        echo "========================================"
        echo "            	FnOS 命令合集"
        echo "========================================"
        echo -e "${NC}"
        echo -e "${YELLOW}当前工作目录: $(pwd)${NC}"
        echo -e "${BLUE}内网IP: $(get_internal_ip)${NC}"
        echo "----------------------------------------"
        echo -e "${YELLOW}请选择要执行的命令：${NC}"
        echo -e "${CYAN}1. Compose 容器管理${NC}"
        echo -e "${CYAN}2. 当前目录 Compose 启动服务${NC}"
        echo -e "${CYAN}3. 当前目录 Compose 停止服务${NC}"
        echo -e "${CYAN}4. 查看所有Docker容器${NC}"
        echo -e "${CYAN}5. 停止指定Docker容器${NC}"
        echo -e "${CYAN}6. 启动指定Docker容器${NC}"
        echo -e "${CYAN}7. 重启指定Docker容器${NC}"
        echo -e "${CYAN}8. 克隆 Docker 项目${NC}"
        echo -e "${RED}0. 返回主菜单${NC}"
        echo "========================================"
        
        if ! safe_read_number "请输入选择" choice 0 8; then
            continue
        fi
        
        case $choice in
            1)
                show_compose_project_menu
                ;;
            2)
                echo -e "${YELLOW}在当前目录执行命令: docker-compose up -d${NC}"
                echo "----------------------------------------"
                docker-compose up -d
                echo "----------------------------------------"
                ;;
            3)
                echo -e "${YELLOW}在当前目录执行命令: docker-compose down${NC}"
                echo "----------------------------------------"
                docker-compose down
                echo "----------------------------------------"
                ;;
            4)
                echo -e "${YELLOW}执行命令: docker ps -a${NC}"
                echo "----------------------------------------"
                docker ps -a
                echo "----------------------------------------"
                ;;
            5)
                if safe_read "请输入要停止的容器名称或ID(输入q退出)" container; then
                    if [ -n "$container" ]; then
                        echo -e "${YELLOW}停止容器: $container${NC}"
                        docker stop $container
                    else
                        echo -e "${RED}错误: 未输入容器名称或ID${NC}"
                    fi
                fi
                ;;
            6)
                if safe_read "请输入要启动的容器名称或ID(输入q退出)" container; then
                    if [ -n "$container" ]; then
                        echo -e "${YELLOW}启动容器: $container${NC}"
                        docker start $container
                    else
                        echo -e "${RED}错误: 未输入容器名称或ID${NC}"
                    fi
                fi
                ;;
            7)
                if safe_read "请输入要重启的容器名称或ID(输入q退出)" container; then
                    if [ -n "$container" ]; then
                        echo -e "${YELLOW}重启容器: $container${NC}"
                        docker restart $container
                    else
                        echo -e "${RED}错误: 未输入容器名称或ID${NC}"
                    fi
                fi
                ;;
            8)
                clone_docker_project
                ;;
            0)
                break
                ;;
            *)
                echo -e "${RED}无效的选择，请重新输入${NC}"
                ;;
        esac
        
        echo ""
        echo -e "${YELLOW}按任意键继续...${NC}"
        read -n 1 -s
    done
}

# 函数：克隆Docker项目
clone_docker_project() {
    echo -e "${YELLOW}克隆 Docker 项目${NC}"
    echo "----------------------------------------"
    echo -e "${BLUE}当前工作目录: $(pwd)${NC}"
    
    if ! safe_read "请输入目标目录(回车使用当前目录，输入q退出)" target_dir "."; then
        return
    fi
    
    if [ "$target_dir" != "." ]; then
        # 如果目录不存在，询问是否创建
        if [ ! -d "$target_dir" ]; then
            if ! safe_read_confirm "目录不存在，是否创建" create_dir; then
                return
            fi
            if [ "$create_dir" = "y" ]; then
                mkdir -p "$target_dir"
                if [ $? -ne 0 ]; then
                    echo -e "${RED}目录创建失败${NC}"
                    return 1
                fi
            else
                echo -e "${RED}操作取消${NC}"
                return 1
            fi
        fi
    fi
    
    echo -e "${GREEN}将在目录: $target_dir 执行克隆命令${NC}"
    echo -e "${YELLOW}执行命令: bash <(curl -sL gitee.com/meimolihan/script/raw/master/sh/compose/git_clone_docker.sh)${NC}"
    echo "----------------------------------------"
    
    # 切换到目标目录
    cd "$target_dir"
    bash <(curl -sL gitee.com/meimolihan/script/raw/master/sh/compose/git_clone_docker.sh)
    echo "----------------------------------------"
    
    echo -e "${GREEN}克隆完成，当前目录: $(pwd)${NC}"
}

# 函数：显示Compose项目菜单
show_compose_project_menu() {
    local base_path="/vol1/1000/compose"
    
    if [ ! -d "$base_path" ]; then
        echo -e "${RED}错误: 路径 $base_path 不存在${NC}"
        echo -e "${YELLOW}按任意键继续...${NC}"
        read -n 1 -s
        return
    fi
    
    while true; do
        clear
        echo -e "${GREEN}"
        echo "========================================"
        echo "      Compose 项目列表 - $base_path"
        echo "========================================"
        echo -e "${NC}"
        echo -e "${YELLOW}当前工作目录: $(pwd)${NC}"
        echo -e "${BLUE}基础路径: $base_path${NC}"
        echo -e "${BLUE}内网IP: $(get_internal_ip)${NC}"
        echo "----------------------------------------"
        echo -e "${YELLOW}请选择要进入的项目：${NC}"
        
        # 获取目录列表并排序
        local projects=()
        local count=0
        
        # 读取目录，排除隐藏目录
        for dir in "$base_path"/*/; do
            if [ -d "$dir" ]; then
                local dir_name=$(basename "$dir")
                # 排除以 . 开头的隐藏目录
                if [[ ! "$dir_name" =~ ^\. ]]; then
                    projects+=("$dir_name")
                fi
            fi
        done
        
        # 按字母顺序排序
        IFS=$'\n' projects=($(sort <<<"${projects[*]}"))
        unset IFS
        
        # 显示项目列表，每行两个
        count=0
        for project in "${projects[@]}"; do
            count=$((count + 1))
            printf "${CYAN}%2d. 进入 %-30s${NC}" "$count" "$project"
            # 每行显示两个项目
            if [ $((count % 2)) -eq 0 ]; then
                echo ""
            fi
        done
        
        # 如果项目数是奇数，确保最后换行
        if [ $((count % 2)) -eq 1 ]; then
            echo ""
        fi
        
        echo "----------------------------------------"
        echo -e "${RED}0. 返回上一级${NC}"
        echo "========================================"
        
        if ! safe_read_number "请输入选择" project_choice 0 $count; then
            continue
        fi
        
        if [ "$project_choice" -eq 0 ]; then
            break
        elif [ "$project_choice" -ge 1 ] && [ "$project_choice" -le $count ]; then
            local selected_project="${projects[$((project_choice - 1))]}"
            local full_path="$base_path/$selected_project"
            echo -e "${GREEN}已选择项目: $selected_project${NC}"
            echo -e "${BLUE}项目路径: $full_path${NC}"
            cd "$full_path"
            show_compose_commands_menu
        else
            echo -e "${RED}无效的选择，请重新输入${NC}"
            sleep 1
        fi
    done
}

# 函数：显示Compose命令菜单
show_compose_commands_menu() {
    while true; do
        clear
        echo -e "${GREEN}"
        echo "========================================"
        echo "        Compose 命令菜单"
        echo "========================================"
        echo -e "${NC}"
        echo -e "${YELLOW}当前工作目录: $(pwd)${NC}"
        echo -e "${BLUE}内网IP: $(get_internal_ip)${NC}"
        echo "----------------------------------------"
        echo -e "${YELLOW}请选择要执行的 Compose 命令：${NC}"
        echo -e "${CYAN}1. 启动服务 (docker-compose up -d)${NC}"
        echo -e "${CYAN}2. 停止服务 (docker-compose down)${NC}"
        echo -e "${CYAN}3. 重启服务 (docker-compose restart)${NC}"
        echo -e "${CYAN}4. 查看服务状态 (docker-compose ps)${NC}"
        echo -e "${CYAN}5. 查看服务日志 (docker-compose logs)${NC}"
        echo -e "${CYAN}6. 重新构建并启动 (docker-compose up -d --build)${NC}"
        echo -e "${RED}0. 返回项目列表${NC}"
        echo "========================================"
        
        if ! safe_read_number "请输入选择" cmd_choice 0 6; then
            continue
        fi
        
        case $cmd_choice in
            1)
                echo -e "${YELLOW}执行命令: docker-compose up -d${NC}"
                echo "----------------------------------------"
                docker-compose up -d
                echo "----------------------------------------"
                ;;
            2)
                echo -e "${YELLOW}执行命令: docker-compose down${NC}"
                echo "----------------------------------------"
                docker-compose down
                echo "----------------------------------------"
                ;;
            3)
                echo -e "${YELLOW}执行命令: docker-compose restart${NC}"
                echo "----------------------------------------"
                docker-compose restart
                echo "----------------------------------------"
                ;;
            4)
                echo -e "${YELLOW}执行命令: docker-compose ps${NC}"
                echo "----------------------------------------"
                docker-compose ps
                echo "----------------------------------------"
                ;;
            5)
                echo -e "${YELLOW}执行命令: docker-compose logs${NC}"
                echo "----------------------------------------"
                docker-compose logs
                echo "----------------------------------------"
                ;;
            6)
                echo -e "${YELLOW}执行命令: docker-compose up -d --build${NC}"
                echo "----------------------------------------"
                docker-compose up -d --build
                echo "----------------------------------------"
                ;;
            0)
                break
                ;;
            *)
                echo -e "${RED}无效的选择，请重新输入${NC}"
                ;;
        esac
        
        echo ""
        echo -e "${YELLOW}按任意键继续...${NC}"
        read -n 1 -s
    done
}

# 函数：显示Nginx子菜单
show_nginx_menu() {
    while true; do
        clear
        echo -e "${GREEN}"
        echo "========================================"
        echo "           Nginx 命令合集"
        echo "========================================"
        echo -e "${NC}"
        echo -e "${YELLOW}当前工作目录: $(pwd)${NC}"
        echo -e "${BLUE}内网IP: $(get_internal_ip)${NC}"
        echo "----------------------------------------"
        echo -e "${YELLOW}请选择要执行的命令：${NC}"
        echo -e "${CYAN}1. 测试Nginx配置${NC}"
        echo -e "${CYAN}2. 测试并重启Nginx${NC}"
        echo -e "${RED}0. 返回主菜单${NC}"
        echo "========================================"
        
        if ! safe_read_number "请输入选择" choice 0 2; then
            continue
        fi
        
        case $choice in
            1)
                echo -e "${YELLOW}执行命令: nginx -t${NC}"
                echo "----------------------------------------"
                nginx -t
                echo "----------------------------------------"
                ;;
            2)
                echo -e "${YELLOW}执行命令: sudo nginx -t && sudo systemctl restart nginx${NC}"
                echo "----------------------------------------"
                sudo nginx -t && sudo systemctl restart nginx
                echo "----------------------------------------"
                ;;
            0)
                break
                ;;
            *)
                echo -e "${RED}无效的选择，请重新输入${NC}"
                ;;
        esac
        
        echo ""
        echo -e "${YELLOW}按任意键继续...${NC}"
        read -n 1 -s
    done
}

# 函数：显示Linux通用子菜单
show_linux_menu() {
    while true; do
        clear
        echo -e "${GREEN}"
        echo "========================================"
        echo "          Linux 通用命令"
        echo "========================================"
        echo -e "${NC}"
        echo -e "${YELLOW}当前工作目录: $(pwd)${NC}"
        echo -e "${BLUE}内网IP: $(get_internal_ip)${NC}"
        echo "----------------------------------------"
        echo -e "${YELLOW}请选择要执行的命令：${NC}"
        echo -e "${CYAN}1. 更新并清理系统${NC}"
        echo -e "${CYAN}2. 安装软件${NC}"
        echo -e "${CYAN}3. 卸载软件${NC}"
        echo -e "${CYAN}4. 创建文件夹${NC}"
        echo -e "${CYAN}5. 文件夹加权限${NC}"
        echo -e "${CYAN}6. 文件加可执行权限${NC}"
        echo -e "${RED}0. 返回主菜单${NC}"
        echo "========================================"
        
        if ! safe_read_number "请输入选择" choice 0 6; then
            continue
        fi
        
        case $choice in
            1)
                echo -e "${YELLOW}更新并清理系统...${NC}"
                echo "----------------------------------------"
                # 检测系统类型
                if command -v apt >/dev/null 2>&1; then
                    # Debian/Ubuntu
                    echo "检测到 Debian/Ubuntu 系统"
                    sudo apt update && sudo apt upgrade -y && sudo apt autoremove -y && sudo apt autoclean
                elif command -v yum >/dev/null 2>&1; then
                    # CentOS/RHEL
                    echo "检测到 CentOS/RHEL 系统"
                    sudo yum update -y && sudo yum autoremove -y
                elif command -v dnf >/dev/null 2>&1; then
                    # Fedora
                    echo "检测到 Fedora 系统"
                    sudo dnf update -y && sudo dnf autoremove -y
                else
                    echo -e "${RED}错误: 不支持的包管理器${NC}"
                fi
                echo "----------------------------------------"
                ;;
            2)
                if safe_read "请输入要安装的软件包名称(输入q退出)" package; then
                    if [ -n "$package" ]; then
                        echo -e "${YELLOW}安装软件: $package${NC}"
                        echo "----------------------------------------"
                        # 检测系统类型
                        if command -v apt >/dev/null 2>&1; then
                            sudo apt update && sudo apt install -y $package
                        elif command -v yum >/dev/null 2>&1; then
                            sudo yum install -y $package
                        elif command -v dnf >/dev/null 2>&1; then
                            sudo dnf install -y $package
                        else
                            echo -e "${RED}错误: 不支持的包管理器${NC}"
                        fi
                        echo "----------------------------------------"
                    else
                        echo -e "${RED}错误: 未输入软件包名称${NC}"
                    fi
                fi
                ;;
            3)
                if safe_read "请输入要卸载的软件包名称(输入q退出)" package; then
                    if [ -n "$package" ]; then
                        echo -e "${YELLOW}卸载软件: $package${NC}"
                        echo "----------------------------------------"
                        # 检测系统类型
                        if command -v apt >/dev/null 2>&1; then
                            sudo apt remove -y $package
                        elif command -v yum >/dev/null 2>&1; then
                            sudo yum remove -y $package
                        elif command -v dnf >/dev/null 2>&1; then
                            sudo dnf remove -y $package
                        else
                            echo -e "${RED}错误: 不支持的包管理器${NC}"
                        fi
                        echo "----------------------------------------"
                    else
                        echo -e "${RED}错误: 未输入软件包名称${NC}"
                    fi
                fi
                ;;
            4)
                if safe_read "请输入要创建的文件夹路径(输入q退出)" dir_path; then
                    if [ -n "$dir_path" ]; then
                        echo -e "${YELLOW}创建文件夹: $dir_path${NC}"
                        mkdir -p "$dir_path"
                        if [ $? -eq 0 ]; then
                            echo -e "${GREEN}文件夹创建成功${NC}"
                        else
                            echo -e "${RED}文件夹创建失败${NC}"
                        fi
                    else
                        echo -e "${RED}错误: 未输入文件夹路径${NC}"
                    fi
                fi
                ;;
            5)
                if safe_read "请输入要设置权限的文件夹路径(输入q退出)" dir_path; then
                    if [ -n "$dir_path" ]; then
                        if [ -d "$dir_path" ]; then
                            if safe_read "请输入权限(如 755)" perm; then
                                if [ -n "$perm" ]; then
                                    echo -e "${YELLOW}设置文件夹 $dir_path 权限为 $perm${NC}"
                                    chmod $perm "$dir_path"
                                    if [ $? -eq 0 ]; then
                                        echo -e "${GREEN}权限设置成功${NC}"
                                    else
                                        echo -e "${RED}权限设置失败${NC}"
                                    fi
                                else
                                    echo -e "${RED}错误: 未输入权限${NC}"
                                fi
                            fi
                        else
                            echo -e "${RED}错误: 文件夹不存在${NC}"
                        fi
                    else
                        echo -e "${RED}错误: 未输入文件夹路径${NC}"
                    fi
                fi
                ;;
            6)
                if safe_read "请输入要加执行权限的文件路径(输入q退出)" file_path; then
                    if [ -n "$file_path" ]; then
                        if [ -f "$file_path" ]; then
                            echo -e "${YELLOW}给文件 $file_path 添加执行权限${NC}"
                            chmod +x "$file_path"
                            if [ $? -eq 0 ]; then
                                echo -e "${GREEN}权限添加成功${NC}"
                            else
                                echo -e "${RED}权限添加失败${NC}"
                            fi
                        else
                            echo -e "${RED}错误: 文件不存在${NC}"
                        fi
                    else
                        echo -e "${RED}错误: 未输入文件路径${NC}"
                    fi
                fi
                ;;
            0)
                break
                ;;
            *)
                echo -e "${RED}无效的选择，请重新输入${NC}"
                ;;
        esac
        
        echo ""
        echo -e "${YELLOW}按任意键继续...${NC}"
        read -n 1 -s
    done
}

# 函数：显示Linux文件命令子菜单
show_linux_file_menu() {
    while true; do
        clear
        echo -e "${GREEN}"
        echo "========================================"
        echo "          Linux 文件命令"
        echo "========================================"
        echo -e "${NC}"
        echo -e "${YELLOW}当前工作目录: $(pwd)${NC}"
        echo -e "${BLUE}内网IP: $(get_internal_ip)${NC}"
        echo "----------------------------------------"
        echo -e "${YELLOW}请选择要执行的命令：${NC}"
        echo -e "${CYAN}1. 创建文件${NC}"
        echo -e "${CYAN}2. 创建文件夹${NC}"
        echo -e "${CYAN}3. 文件添加权限${NC}"
        echo -e "${CYAN}4. 文件夹添加权限${NC}"
        echo -e "${CYAN}5. 文件搜索${NC}"
        echo -e "${CYAN}6. 删除文件${NC}"
        echo -e "${RED}0. 返回主菜单${NC}"
        echo "========================================"
        
        if ! safe_read_number "请输入选择" choice 0 6; then
            continue
        fi
        
        case $choice in
            1)
                create_file
                ;;
            2)
                create_directory
                ;;
            3)
                add_file_permission
                ;;
            4)
                add_directory_permission
                ;;
            5)
                search_file
                ;;
            6)
                delete_file
                ;;
            0)
                break
                ;;
            *)
                echo -e "${RED}无效的选择，请重新输入${NC}"
                ;;
        esac
        
        echo ""
        echo -e "${YELLOW}按任意键继续...${NC}"
        read -n 1 -s
    done
}

# 函数：创建文件
create_file() {
    while true; do
        echo -e "${YELLOW}创建文件${NC}"
        echo "----------------------------------------"
        
        if ! safe_read "请输入文件名(输入q退出)" file_name; then
            return
        fi
        
        # 检查文件是否已存在
        if [ -e "$file_name" ]; then
            echo -e "${RED}错误: 文件 '$file_name' 已存在${NC}"
            if ! safe_read_confirm "是否覆盖" overwrite; then
                continue
            fi
            if [ "$overwrite" != "y" ]; then
                continue
            fi
        fi
        
        echo -e "${GREEN}将创建文件: $file_name${NC}"
        echo -e "${YELLOW}请输入文件内容(输入 'EOF' 单独一行结束输入):${NC}"
        
        # 创建临时文件来存储内容
        temp_file=$(mktemp)
        
        # 读取多行输入
        line_count=0
        while IFS= read -r line; do
            if [ "$line" = "EOF" ]; then
                break
            fi
            echo "$line" >> "$temp_file"
            line_count=$((line_count + 1))
        done
        
        if [ $line_count -eq 0 ]; then
            echo -e "${YELLOW}未输入内容，创建空文件${NC}"
            touch "$file_name"
        else
            # 将内容写入目标文件
            mv "$temp_file" "$file_name"
            echo -e "${GREEN}文件 '$file_name' 创建成功，共写入 $line_count 行${NC}"
        fi
        
        # 显示文件内容预览
        echo -e "${YELLOW}文件内容预览:${NC}"
        echo "----------------------------------------"
        cat "$file_name" 2>/dev/null || echo -e "${RED}无法显示文件内容${NC}"
        echo "----------------------------------------"
        
        # 根据文件后缀提示添加权限
        if [[ "$file_name" =~ \.sh$ ]] || [[ "$file_name" =~ \.py$ ]] || [[ "$file_name" =~ \.pl$ ]]; then
            if ! safe_read_confirm "检测到脚本文件，是否添加执行权限" add_exec; then
                continue
            fi
            if [ "$add_exec" = "y" ]; then
                chmod +x "$file_name"
                echo -e "${GREEN}已为文件 '$file_name' 添加执行权限${NC}"
            fi
        fi
        
        if ! safe_read_confirm "是否继续创建其他文件" continue_create; then
            break
        fi
        if [ "$continue_create" != "y" ]; then
            break
        fi
    done
}

# 函数：创建文件夹
create_directory() {
    while true; do
        echo -e "${YELLOW}创建文件夹${NC}"
        echo "----------------------------------------"
        
        if ! safe_read "请输入文件夹名(输入q退出)" dir_name; then
            return
        fi
        
        # 检查文件夹是否已存在
        if [ -d "$dir_name" ]; then
            echo -e "${RED}错误: 文件夹 '$dir_name' 已存在${NC}"
            if ! safe_read_confirm "是否继续创建其他文件夹" continue_create; then
                break
            fi
            if [ "$continue_create" != "y" ]; then
                break
            else
                continue
            fi
        fi
        
        echo -e "${YELLOW}执行命令: mkdir -p $dir_name${NC}"
        mkdir -p "$dir_name"
        
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}文件夹 '$dir_name' 创建成功${NC}"
            echo -e "${BLUE}完整路径: $(pwd)/$dir_name${NC}"
            
            # 提示添加文件夹权限
            echo -e "${YELLOW}是否设置文件夹权限?${NC}"
            echo -e "${CYAN}示例权限: ${NC}"
            echo -e "${CYAN}  755 - 所有者可读可写可执行，组和其他用户可读可执行${NC}"
            echo -e "${CYAN}  777 - 所有用户可读可写可执行${NC}"
            echo -e "${CYAN}  644 - 所有者可读可写，组和其他用户只读${NC}"
            
            if safe_read "请输入权限(回车使用默认755)" perm "755"; then
                if [[ "$perm" =~ ^[0-7]{3}$ ]]; then
                    chmod $perm "$dir_name"
                    echo -e "${GREEN}已设置文件夹 '$dir_name' 权限为 $perm${NC}"
                else
                    echo -e "${RED}无效的权限格式，使用默认权限755${NC}"
                    chmod 755 "$dir_name"
                fi
            fi
        else
            echo -e "${RED}文件夹创建失败${NC}"
        fi
        
        if ! safe_read_confirm "是否继续创建其他文件夹" continue_create; then
            break
        fi
        if [ "$continue_create" != "y" ]; then
            break
        fi
    done
}

# 函数：文件添加权限
add_file_permission() {
    while true; do
        echo -e "${YELLOW}文件添加权限${NC}"
        echo "----------------------------------------"
        echo -e "${BLUE}当前目录文件列表:${NC}"
        echo "----------------------------------------"
        
        # 获取当前目录的文件列表（排除目录）
        local files=()
        local count=0
        
        while IFS= read -r -d $'\0' file; do
            if [ -f "$file" ]; then
                files+=("$file")
            fi
        done < <(find . -maxdepth 1 -type f -print0 2>/dev/null | sort -z)
        
        # 显示文件列表
        count=0
        for file in "${files[@]}"; do
            count=$((count + 1))
            file_perms=$(ls -la "$file" | awk '{print $1}')
            file_size=$(ls -la "$file" | awk '{print $5}')
            printf "${CYAN}%2d. ${YELLOW}%-30s ${BLUE}(%s, %s bytes)${NC}\n" "$count" "$(basename "$file")" "$file_perms" "$file_size"
        done
        
        if [ $count -eq 0 ]; then
            echo -e "${RED}当前目录没有文件${NC}"
            return
        fi
        
        echo "----------------------------------------"
        echo -e "${YELLOW}请选择操作方式:${NC}"
        echo -e "${CYAN}1. 从列表中选择文件${NC}"
        echo -e "${CYAN}2. 手动输入文件路径${NC}"
        echo -e "${RED}0. 返回上一级${NC}"
        
        if ! safe_read_number "请输入选择" choice 0 2; then
            continue
        fi
        
        case $choice in
            1)
                if [ $count -eq 0 ]; then
                    echo -e "${RED}没有文件可供选择${NC}"
                    continue
                fi
                
                if ! safe_read_number "请输入文件序号" file_index 1 $count; then
                    continue
                fi
                
                selected_file="${files[$((file_index - 1))]}"
                echo -e "${GREEN}已选择文件: $selected_file${NC}"
                ;;
            2)
                if ! safe_read "请输入文件路径" selected_file; then
                    continue
                fi
                if [ ! -f "$selected_file" ]; then
                    echo -e "${RED}错误: 文件不存在${NC}"
                    continue
                fi
                ;;
            0)
                return
                ;;
            *)
                echo -e "${RED}无效的选择${NC}"
                continue
                ;;
        esac
        
        # 根据文件后缀提示添加权限
        echo -e "${YELLOW}文件: $selected_file${NC}"
        file_perms=$(ls -la "$selected_file" | awk '{print $1}')
        echo -e "${BLUE}当前权限: $file_perms${NC}"
        
        if [[ "$selected_file" =~ \.sh$ ]] || [[ "$selected_file" =~ \.py$ ]] || [[ "$selected_file" =~ \.pl$ ]]; then
            echo -e "${YELLOW}检测到脚本文件，建议添加执行权限${NC}"
            if ! safe_read_confirm "是否添加执行权限" add_exec; then
                continue
            fi
            if [ "$add_exec" = "y" ]; then
                chmod +x "$selected_file"
                echo -e "${GREEN}已为文件 '$selected_file' 添加执行权限${NC}"
            fi
        else
            echo -e "${YELLOW}请选择要设置的权限:${NC}"
            echo -e "${CYAN}1. 添加执行权限 (+x)${NC}"
            echo -e "${CYAN}2. 设置为可读可写 (644)${NC}"
            echo -e "${CYAN}3. 设置为可读可写可执行 (755)${NC}"
            echo -e "${CYAN}4. 自定义权限${NC}"
            echo -e "${RED}0. 跳过${NC}"
            
            if ! safe_read_number "请输入选择" perm_choice 0 4; then
                continue
            fi
            
            case $perm_choice in
                1)
                    chmod +x "$selected_file"
                    echo -e "${GREEN}已为文件 '$selected_file' 添加执行权限${NC}"
                    ;;
                2)
                    chmod 644 "$selected_file"
                    echo -e "${GREEN}已设置文件 '$selected_file' 权限为644${NC}"
                    ;;
                3)
                    chmod 755 "$selected_file"
                    echo -e "${GREEN}已设置文件 '$selected_file' 权限为755${NC}"
                    ;;
                4)
                    if safe_read "请输入权限(如 755)" custom_perm; then
                        if [[ "$custom_perm" =~ ^[0-7]{3}$ ]]; then
                            chmod $custom_perm "$selected_file"
                            echo -e "${GREEN}已设置文件 '$selected_file' 权限为 $custom_perm${NC}"
                        else
                            echo -e "${RED}无效的权限格式${NC}"
                        fi
                    fi
                    ;;
                0)
                    echo -e "${YELLOW}跳过权限设置${NC}"
                    ;;
                *)
                    echo -e "${RED}无效的选择${NC}"
                    ;;
            esac
        fi
        
        # 显示更新后的权限
        new_perms=$(ls -la "$selected_file" | awk '{print $1}')
        echo -e "${BLUE}更新后权限: $new_perms${NC}"
        
        if ! safe_read_confirm "是否继续设置其他文件权限" continue_set; then
            break
        fi
        if [ "$continue_set" != "y" ]; then
            break
        fi
    done
}

# 函数：文件夹添加权限
add_directory_permission() {
    while true; do
        echo -e "${YELLOW}文件夹添加权限${NC}"
        echo "----------------------------------------"
        echo -e "${BLUE}当前目录文件夹列表:${NC}"
        echo "----------------------------------------"
        
        # 获取当前目录的文件夹列表
        local dirs=()
        local count=0
        
        while IFS= read -r -d $'\0' dir; do
            if [ -d "$dir" ] && [ "$dir" != "." ] && [ "$dir" != ".." ]; then
                dirs+=("$dir")
            fi
        done < <(find . -maxdepth 1 -type d -print0 2>/dev/null | sort -z)
        
        # 显示文件夹列表
        count=0
        for dir in "${dirs[@]}"; do
            count=$((count + 1))
            dir_perms=$(ls -la "$dir" | awk '{print $1}')
            printf "${CYAN}%2d. ${YELLOW}%-30s ${BLUE}(%s)${NC}\n" "$count" "$(basename "$dir")" "$dir_perms"
        done
        
        if [ $count -eq 0 ]; then
            echo -e "${RED}当前目录没有文件夹${NC}"
            return
        fi
        
        echo "----------------------------------------"
        echo -e "${YELLOW}请选择操作方式:${NC}"
        echo -e "${CYAN}1. 从列表中选择文件夹${NC}"
        echo -e "${CYAN}2. 手动输入文件夹路径${NC}"
        echo -e "${RED}0. 返回上一级${NC}"
        
        if ! safe_read_number "请输入选择" choice 0 2; then
            continue
        fi
        
        case $choice in
            1)
                if [ $count -eq 0 ]; then
                    echo -e "${RED}没有文件夹可供选择${NC}"
                    continue
                fi
                
                if ! safe_read_number "请输入文件夹序号" dir_index 1 $count; then
                    continue
                fi
                
                selected_dir="${dirs[$((dir_index - 1))]}"
                echo -e "${GREEN}已选择文件夹: $selected_dir${NC}"
                ;;
            2)
                if ! safe_read "请输入文件夹路径" selected_dir; then
                    continue
                fi
                if [ ! -d "$selected_dir" ]; then
                    echo -e "${RED}错误: 文件夹不存在${NC}"
                    continue
                fi
                ;;
            0)
                return
                ;;
            *)
                echo -e "${RED}无效的选择${NC}"
                continue
                ;;
        esac
        
        # 显示当前权限并设置新权限
        echo -e "${YELLOW}文件夹: $selected_dir${NC}"
        dir_perms=$(ls -la "$selected_dir" | awk '{print $1}')
        echo -e "${BLUE}当前权限: $dir_perms${NC}"
        
        echo -e "${YELLOW}请选择要设置的权限:${NC}"
        echo -e "${CYAN}示例权限: ${NC}"
        echo -e "${CYAN}  755 - 所有者可读可写可执行，组和其他用户可读可执行 (推荐)${NC}"
        echo -e "${CYAN}  777 - 所有用户可读可写可执行 (谨慎使用)${NC}"
        echo -e "${CYAN}  700 - 仅所有者可读可写可执行${NC}"
        echo -e "${CYAN}  1. 使用推荐权限 (755)${NC}"
        echo -e "${CYAN}  2. 完全开放权限 (777)${NC}"
        echo -e "${CYAN}  3. 私有权限 (700)${NC}"
        echo -e "${CYAN}  4. 自定义权限${NC}"
        echo -e "${RED}  0. 跳过${NC}"
        
        if ! safe_read_number "请输入选择" perm_choice 0 4; then
            continue
        fi
        
        case $perm_choice in
            1)
                chmod 755 "$selected_dir"
                echo -e "${GREEN}已设置文件夹 '$selected_dir' 权限为755${NC}"
                ;;
            2)
                if ! safe_read_confirm "警告: 777权限非常开放，确定要继续" confirm; then
                    continue
                fi
                if [ "$confirm" = "y" ]; then
                    chmod 777 "$selected_dir"
                    echo -e "${GREEN}已设置文件夹 '$selected_dir' 权限为777${NC}"
                else
                    echo -e "${YELLOW}已取消设置权限${NC}"
                fi
                ;;
            3)
                chmod 700 "$selected_dir"
                echo -e "${GREEN}已设置文件夹 '$selected_dir' 权限为700${NC}"
                ;;
            4)
                if safe_read "请输入权限(如 755)" custom_perm; then
                    if [[ "$custom_perm" =~ ^[0-7]{3}$ ]]; then
                        chmod $custom_perm "$selected_dir"
                        echo -e "${GREEN}已设置文件夹 '$selected_dir' 权限为 $custom_perm${NC}"
                    else
                        echo -e "${RED}无效的权限格式${NC}"
                    fi
                fi
                ;;
            0)
                echo -e "${YELLOW}跳过权限设置${NC}"
                ;;
            *)
                echo -e "${RED}无效的选择${NC}"
                ;;
        esac
        
        # 显示更新后的权限
        new_perms=$(ls -la "$selected_dir" | awk '{print $1}')
        echo -e "${BLUE}更新后权限: $new_perms${NC}"
        
        if ! safe_read_confirm "是否继续设置其他文件夹权限" continue_set; then
            break
        fi
        if [ "$continue_set" != "y" ]; then
            break
        fi
    done
}

# 函数：文件搜索
search_file() {
    while true; do
        echo -e "${YELLOW}文件搜索${NC}"
        echo "----------------------------------------"
        echo -e "${YELLOW}请选择搜索范围:${NC}"
        echo -e "${CYAN}1. 当前目录搜索${NC}"
        echo -e "${CYAN}2. 指定目录搜索${NC}"
        echo -e "${RED}0. 返回上一级${NC}"
        
        if ! safe_read_number "请输入选择" scope_choice 0 2; then
            continue
        fi
        
        case $scope_choice in
            1)
                search_path="."
                ;;
            2)
                if ! safe_read "请输入搜索目录路径" search_path; then
                    continue
                fi
                if [ ! -d "$search_path" ]; then
                    echo -e "${RED}错误: 目录不存在${NC}"
                    continue
                fi
                ;;
            0)
                return
                ;;
            *)
                echo -e "${RED}无效的选择${NC}"
                continue
                ;;
        esac
        
        echo -e "${YELLOW}请选择搜索模式:${NC}"
        echo -e "${CYAN}1. 精确搜索 (按完整文件名)${NC}"
        echo -e "${CYAN}2. 模糊搜索 (按文件名包含)${NC}"
        echo -e "${CYAN}3. 扩展名搜索 (按文件后缀)${NC}"
        echo -e "${CYAN}4. 大小写不敏感搜索${NC}"
        
        if ! safe_read_number "请输入搜索模式" search_mode 1 4; then
            continue
        fi
        
        case $search_mode in
            1)
                if ! safe_read "请输入完整文件名(支持通配符 *)" search_name; then
                    continue
                fi
                find_cmd="find \"$search_path\" -name \"$search_name\""
                echo -e "${YELLOW}执行命令: $find_cmd${NC}"
                ;;
            2)
                if ! safe_read "请输入文件名包含的文本" search_name; then
                    continue
                fi
                find_cmd="find \"$search_path\" -name \"*$search_name*\""
                echo -e "${YELLOW}执行命令: $find_cmd${NC}"
                ;;
            3)
                if ! safe_read "请输入文件扩展名(如: txt, sh, py)" search_name; then
                    continue
                fi
                find_cmd="find \"$search_path\" -name \"*.$search_name\""
                echo -e "${YELLOW}执行命令: $find_cmd${NC}"
                ;;
            4)
                if ! safe_read "请输入搜索名称(不区分大小写)" search_name; then
                    continue
                fi
                find_cmd="find \"$search_path\" -iname \"*$search_name*\""
                echo -e "${YELLOW}执行命令: $find_cmd${NC}"
                ;;
            *)
                echo -e "${RED}无效的搜索模式${NC}"
                continue
                ;;
        esac
        
        echo "----------------------------------------"
        
        # 执行搜索
        result_count=0
        while IFS= read -r -d $'\0' file; do
            result_count=$((result_count + 1))
            file_type=""
            file_color=""
            
            if [ -d "$file" ]; then
                file_type="[目录]"
                file_color="${CYAN}"
            elif [ -f "$file" ]; then
                if [ -x "$file" ]; then
                    file_type="[可执行文件]"
                    file_color="${GREEN}"
                else
                    file_type="[文件]"
                    file_color="${GREEN}"
                fi
            elif [ -L "$file" ]; then
                file_type="[链接]"
                file_color="${PURPLE}"
            else
                file_type="[其他]"
                file_color="${YELLOW}"
            fi
            
            # 获取文件大小和权限
            file_size=$(ls -la "$file" 2>/dev/null | awk '{print $5}')
            file_perms=$(ls -la "$file" 2>/dev/null | awk '{print $1}')
            file_date=$(ls -la "$file" 2>/dev/null | awk '{print $6, $7, $8}')
            
            echo -e "${file_color}${file_type} $file ${BLUE}(大小: ${file_size}, 权限: ${file_perms}, 日期: ${file_date})${NC}"
        done < <(eval "$find_cmd -print0" 2>/dev/null)
        
        if [ $result_count -eq 0 ]; then
            echo -e "${RED}未找到匹配的文件或目录${NC}"
        else
            echo "----------------------------------------"
            echo -e "${GREEN}找到 $result_count 个结果${NC}"
            
            # 提供进一步操作的选项
            echo "----------------------------------------"
            echo -e "${YELLOW}是否对搜索结果执行操作?${NC}"
            echo -e "${CYAN}1. 查看文件内容${NC}"
            echo -e "${CYAN}2. 复制文件${NC}"
            echo -e "${CYAN}3. 移动文件${NC}"
            echo -e "${CYAN}4. 删除文件${NC}"
            echo -e "${RED}0. 不执行操作，继续搜索${NC}"
            
            if ! safe_read_number "请选择" action_choice 0 4; then
                continue
            fi
            
            case $action_choice in
                1)
                    # 重新执行搜索并存储结果
                    search_results=()
                    while IFS= read -r -d $'\0' file; do
                        if [ -f "$file" ] && [ -r "$file" ]; then
                            search_results+=("$file")
                        fi
                    done < <(eval "$find_cmd -print0" 2>/dev/null)
                    
                    if [ ${#search_results[@]} -eq 0 ]; then
                        echo -e "${RED}没有可读的文件${NC}"
                    else
                        echo -e "${YELLOW}请选择要查看的文件:${NC}"
                        for i in "${!search_results[@]}"; do
                            echo -e "${CYAN}$((i+1)). ${search_results[i]}${NC}"
                        done
                        if ! safe_read_number "请输入文件序号" file_index 1 ${#search_results[@]}; then
                            continue
                        fi
                        selected_file="${search_results[$((file_index-1))]}"
                        echo -e "${YELLOW}文件内容: $selected_file${NC}"
                        echo "----------------------------------------"
                        cat "$selected_file" 2>/dev/null || echo -e "${RED}无法读取文件${NC}"
                        echo "----------------------------------------"
                    fi
                    ;;
                2)
                    if safe_read "请输入目标目录" target_dir; then
                        if [ -d "$target_dir" ]; then
                            while IFS= read -r -d $'\0' file; do
                                if [ -f "$file" ]; then
                                    cp "$file" "$target_dir/"
                                    echo -e "${GREEN}已复制: $file -> $target_dir/${NC}"
                                fi
                            done < <(eval "$find_cmd -print0" 2>/dev/null)
                        else
                            echo -e "${RED}目标目录不存在${NC}"
                        fi
                    fi
                    ;;
                3)
                    if safe_read "请输入目标目录" target_dir; then
                        if [ -d "$target_dir" ]; then
                            while IFS= read -r -d $'\0' file; do
                                if [ -f "$file" ]; then
                                    mv "$file" "$target_dir/"
                                    echo -e "${GREEN}已移动: $file -> $target_dir/${NC}"
                                fi
                            done < <(eval "$find_cmd -print0" 2>/dev/null)
                        else
                            echo -e "${RED}目标目录不存在${NC}"
                        fi
                    fi
                    ;;
                4)
                    echo -e "${RED}警告: 这将删除所有搜索到的文件${NC}"
                    if ! safe_read_confirm "确定要删除吗" confirm_delete; then
                        continue
                    fi
                    if [ "$confirm_delete" = "y" ]; then
                        while IFS= read -r -d $'\0' file; do
                            if [ -f "$file" ]; then
                                rm -f "$file"
                                echo -e "${GREEN}已删除: $file${NC}"
                            fi
                        done < <(eval "$find_cmd -print0" 2>/dev/null)
                    else
                        echo -e "${YELLOW}已取消删除${NC}"
                    fi
                    ;;
                0)
                    # 不执行任何操作，继续
                    ;;
                *)
                    echo -e "${RED}无效的选择${NC}"
                    ;;
            esac
        fi
        
        if ! safe_read_confirm "是否继续搜索" continue_search; then
            break
        fi
        if [ "$continue_search" != "y" ]; then
            break
        fi
    done
}

# 函数：删除文件
delete_file() {
    while true; do
        echo -e "${YELLOW}删除文件${NC}"
        echo "----------------------------------------"
        echo -e "${BLUE}当前目录内容列表:${NC}"
        echo "----------------------------------------"
        
        # 获取当前目录的所有内容
        local items=()
        local count=0
        
        while IFS= read -r -d $'\0' item; do
            if [ "$item" != "." ]; then
                items+=("$item")
            fi
        done < <(find . -maxdepth 1 -print0 2>/dev/null | sort -z)
        
        # 显示内容列表
        count=0
        for item in "${items[@]}"; do
            count=$((count + 1))
            item_name=$(basename "$item")
            if [ -d "$item" ]; then
                printf "${CYAN}%2d. ${RED}[目录] %-30s${NC}\n" "$count" "$item_name"
            elif [ -f "$item" ]; then
                printf "${CYAN}%2d. ${GREEN}[文件] %-30s${NC}\n" "$count" "$item_name"
            else
                printf "${CYAN}%2d. ${YELLOW}[其他] %-30s${NC}\n" "$count" "$item_name"
            fi
        done
        
        if [ $count -eq 0 ]; then
            echo -e "${RED}当前目录为空${NC}"
            return
        fi
        
        echo "----------------------------------------"
        echo -e "${YELLOW}请选择操作方式:${NC}"
        echo -e "${CYAN}1. 从列表中选择${NC}"
        echo -e "${CYAN}2. 手动输入路径${NC}"
        echo -e "${RED}0. 返回上一级${NC}"
        
        if ! safe_read_number "请输入选择" choice 0 2; then
            continue
        fi
        
        case $choice in
            1)
                if [ $count -eq 0 ]; then
                    echo -e "${RED}没有内容可供选择${NC}"
                    continue
                fi
                
                if ! safe_read_number "请输入序号" item_index 1 $count; then
                    continue
                fi
                
                selected_item="${items[$((item_index - 1))]}"
                echo -e "${GREEN}已选择: $selected_item${NC}"
                ;;
            2)
                if ! safe_read "请输入要删除的路径" selected_item; then
                    continue
                fi
                if [ ! -e "$selected_item" ]; then
                    echo -e "${RED}错误: 路径不存在${NC}"
                    continue
                fi
                ;;
            0)
                return
                ;;
            *)
                echo -e "${RED}无效的选择${NC}"
                continue
                ;;
        esac
        
        # 确认删除
        if [ -d "$selected_item" ]; then
            echo -e "${RED}警告: 您将要删除目录 '$selected_item'${NC}"
            if ! safe_read_confirm "确定要删除这个目录及其所有内容吗" confirm; then
                continue
            fi
        else
            echo -e "${RED}警告: 您将要删除 '$selected_item'${NC}"
            if ! safe_read_confirm "确定要删除吗" confirm; then
                continue
            fi
        fi
        
        if [ "$confirm" = "y" ]; then
            if rm -rf "$selected_item"; then
                echo -e "${GREEN}成功删除: $selected_item${NC}"
            else
                echo -e "${RED}删除失败: $selected_item${NC}"
            fi
        else
            echo -e "${YELLOW}已取消删除${NC}"
        fi
        
        if ! safe_read_confirm "是否继续删除其他文件" continue_delete; then
            break
        fi
        if [ "$continue_delete" != "y" ]; then
            break
        fi
    done
}

# 函数：显示压缩/解压子菜单
show_compress_menu() {
    while true; do
        clear
        echo -e "${GREEN}"
        echo "========================================"
        echo "          Linux 压缩/解压工具"
        echo "========================================"
        echo -e "${NC}"
        echo -e "${YELLOW}当前工作目录: $(pwd)${NC}"
        echo -e "${BLUE}内网IP: $(get_internal_ip)${NC}"
        echo "----------------------------------------"
        echo -e "${YELLOW}请选择要执行的操作：${NC}"
        echo -e "${CYAN}1. 压缩文件/目录${NC}"
        echo -e "${CYAN}2. 解压文件${NC}"
        echo -e "${RED}0. 返回主菜单${NC}"
        echo "========================================"
        
        if ! safe_read_number "请输入选择" choice 0 2; then
            continue
        fi
        
        case $choice in
            1)
                compress_submenu
                ;;
            2)
                decompress_submenu
                ;;
            0)
                break
                ;;
            *)
                echo -e "${RED}无效的选择，请重新输入${NC}"
                ;;
        esac
        
        echo ""
        echo -e "${YELLOW}按任意键继续...${NC}"
        read -n 1 -s
    done
}

# 函数：压缩子菜单
compress_submenu() {
    while true; do
        clear
        echo -e "${CYAN}"
        echo "=============================================="
        echo ">>> 压缩模式"
        echo "=============================================="
        echo -e "${NC}"
        
        # 扫描当前目录下的文件/目录（排除压缩包）
        mapfile -t list < <(
            find . -maxdepth 1 -type f \( ! -name '*.zip' ! -name '*.7z' ! -name '*.tar*' ! -name '*.rar' ! -name '*.gz' ! -name '*.bz2' ! -name '*.xz' \) -printf '%P\n' | sort
            find . -maxdepth 1 -type d ! -name '.' ! -name '.*' -printf '%P\n' | sort
        )
        
        if ((${#list[@]}==0)); then
            echo -e "${YELLOW}(当前目录无可压缩的文件/目录)${NC}"
            list=()
        else
            echo -e "${CYAN}当前目录下的文件/目录：${NC}"
            for i in "${!list[@]}"; do
                printf "  ${GREEN}%2d)${NC} %s\n" $((i+1)) "${list[i]}"
            done
        fi
        echo -e "${CYAN}==============================================${NC}"
        
        if ! safe_read "请输入序号选择，或手动输入文件名/目录名（留空取消）" choice; then
            echo -e "${YELLOW}已取消${NC}"
            return
        fi
        
        [[ -z $choice ]] && { echo -e "${YELLOW}已取消${NC}"; return; }
        
        # 判断是序号还是手动输入
        if [[ $choice =~ ^[0-9]+$ ]] && (( choice>=1 && choice<=${#list[@]} )); then
            target="${list[$((choice-1))]}"
        else
            target="$choice"
        fi
        
        [[ -e $target ]] || { echo -e "${RED}错误：'$target' 不存在！${NC}"; return; }
        
        echo -e "${YELLOW}请选择压缩格式：${NC}"
        echo -e "  1) zip\n  2) 7z\n  3) tar.gz\n  4) tar.xz\n  5) tar.bz2\n  6) tar"
        
        if ! safe_read_number "输入序号 [1-6]" fmt_idx 1 6; then
            continue
        fi
        
        # 检查对应命令是否存在
        case $fmt_idx in
            1) 
                ext="zip"; cmd=("zip" "-r" "-q")
                if ! command -v zip &> /dev/null; then
                    echo -e "${RED}错误：zip 命令未安装！${NC}"
                    return
                fi
                ;;
            2) 
                ext="7z"; cmd=("7z" "a")
                if ! command -v 7z &> /dev/null; then
                    echo -e "${RED}错误：7z 命令未安装！${NC}"
                    return
                fi
                ;;
            3) 
                ext="tar.gz"; cmd=("tar" "-zcf")
                if ! command -v tar &> /dev/null; then
                    echo -e "${RED}错误：tar 命令未安装！${NC}"
                    return
                fi
                ;;
            4) 
                ext="tar.xz"; cmd=("tar" "-Jcf")
                if ! command -v tar &> /dev/null || ! command -v xz &> /dev/null; then
                    echo -e "${RED}错误：tar 或 xz 命令未安装！${NC}"
                    return
                fi
                ;;
            5) 
                ext="tar.bz2"; cmd=("tar" "-jcf")
                if ! command -v tar &> /dev/null || ! command -v bzip2 &> /dev/null; then
                    echo -e "${RED}错误：tar 或 bzip2 命令未安装！${NC}"
                    return
                fi
                ;;
            6) 
                ext="tar"; cmd=("tar" "-cf")
                if ! command -v tar &> /dev/null; then
                    echo -e "${RED}错误：tar 命令未安装！${NC}"
                    return
                fi
                ;;
            *) echo -e "${RED}无效序号！${NC}"; return ;;
        esac
        
        output="${target%%/}.${ext}"
        echo -e "${GREEN}正在压缩 → ${output}${NC}"
        
        case $fmt_idx in
            1|2) 
                "${cmd[@]}" "$output" "$target" 
                ;;
            3|4|5|6) 
                "${cmd[@]}" "$output" -C "$(dirname "$target")" "$(basename "$target")" 
                ;;
        esac 
        
        if [[ $? -eq 0 ]]; then
            echo -e "${GREEN}压缩完成！${NC}"
        else
            echo -e "${RED}压缩失败！${NC}"
        fi
        
        if ! safe_read_confirm "是否继续压缩其他文件" continue_compress; then
            break
        fi
        if [ "$continue_compress" != "y" ]; then
            break
        fi
    done
}

# 函数：检查重复文件
check_duplicate_files() {
    local archive="$1"
    local dest="$2"
    local duplicates=()
    
    # 根据压缩格式检查重复文件
    case "$archive" in
        *.zip)
            if command -v unzip &> /dev/null; then
                mapfile -t files < <(unzip -Z1 "$archive" 2>/dev/null || true)
                for file in "${files[@]}"; do
                    [[ -n "$file" && "$file" != */ ]] && [[ -f "$dest/$file" ]] && duplicates+=("$file")
                done
            fi
            ;;
        *.7z)
            if command -v 7z &> /dev/null; then
                mapfile -t files < <(7z l "$archive" 2>/dev/null | awk '/^[0-9]{4}-[0-9]{2}-[0-9]{2}/ {if(NF>=6) print $NF}' | grep -v '/$' || true)
                for file in "${files[@]}"; do
                    [[ -n "$file" && "$file" != */ ]] && [[ -f "$dest/$file" ]] && duplicates+=("$file")
                done
            fi
            ;;
        *.tar|*.tar.gz|*.tar.bz2|*.tar.xz|*.tgz|*.tbz2|*.txz)
            if command -v tar &> /dev/null; then
                mapfile -t files < <(tar -tf "$archive" 2>/dev/null || true)
                for file in "${files[@]}"; do
                    [[ -n "$file" && "$file" != */ ]] && [[ -f "$dest/$file" ]] && duplicates+=("$file")
                done
            fi
            ;;
        *.rar)
            if command -v unrar &> /dev/null; then
                mapfile -t files < <(unrar vb "$archive" 2>/dev/null || true)
                for file in "${files[@]}"; do
                    [[ -n "$file" && "$file" != */ ]] && [[ -f "$dest/$file" ]] && duplicates+=("$file")
                done
            fi
            ;;
        # 对于其他格式，跳过重复检查
        *) return ;;
    esac
    
    printf '%s\n' "${duplicates[@]}"
}

# 函数：解压子菜单
decompress_submenu() {
    while true; do
        clear
        echo -e "${CYAN}"
        echo "=============================================="
        echo ">>> 解压模式"
        echo "=============================================="
        echo -e "${NC}"
        
        # 支持更多压缩格式
        mapfile -t list < <(
            ls -1 *.zip *.7z *.tar *.tar.gz *.tar.bz2 *.tar.xz *.tgz *.tbz2 *.txz *.rar *.gz *.bz2 *.xz 2>/dev/null | sort -u
        )
        
        if ((${#list[@]}==0)); then
            echo -e "${YELLOW}(当前目录无压缩包)${NC}"
            list=()
        else
            echo -e "${CYAN}当前目录下的压缩包：${NC}"
            for i in "${!list[@]}"; do
                printf "  ${GREEN}%2d)${NC} %s\n" $((i+1)) "${list[i]}"
            done
        fi
        echo -e "${CYAN}==============================================${NC}"
        
        if ! safe_read "请输入序号选择，或手动输入文件名（留空取消）" choice; then
            echo -e "${YELLOW}已取消${NC}"
            return
        fi
        
        [[ -z $choice ]] && { echo -e "${YELLOW}已取消${NC}"; return; }
        
        if [[ $choice =~ ^[0-9]+$ ]] && (( choice>=1 && choice<=${#list[@]} )); then
            archive="${list[$((choice-1))]}"
        else
            archive="$choice"
        fi
        
        [[ -f $archive ]] || { echo -e "${RED}错误：'$archive' 不存在！${NC}"; return; }
        
        # 根据文件扩展名设置解压命令
        local cmd=()
        case "$archive" in
            *.zip)  
                cmd=("unzip" "-q")
                if ! command -v unzip &> /dev/null; then
                    echo -e "${RED}错误：unzip 命令未安装！${NC}"
                    return
                fi
                ;;
            *.7z)   
                cmd=("7z" "x")
                if ! command -v 7z &> /dev/null; then
                    echo -e "${RED}错误：7z 命令未安装！${NC}"
                    return
                fi
                ;;
            *.tar) 
                cmd=("tar" "-xf")
                if ! command -v tar &> /dev/null; then
                    echo -e "${RED}错误：tar 命令未安装！${NC}"
                    return
                fi
                ;;
            *.tar.gz|*.tgz) 
                cmd=("tar" "-zxf")
                if ! command -v tar &> /dev/null; then
                    echo -e "${RED}错误：tar 命令未安装！${NC}"
                    return
                fi
                ;;
            *.tar.bz2|*.tbz2) 
                cmd=("tar" "-jxf")
                if ! command -v tar &> /dev/null; then
                    echo -e "${RED}错误：tar 命令未安装！${NC}"
                    return
                fi
                ;;
            *.tar.xz|*.txz) 
                cmd=("tar" "-Jxf")
                if ! command -v tar &> /dev/null; then
                    echo -e "${RED}错误：tar 命令未安装！${NC}"
                    return
                fi
                ;;
            *.rar)
                if command -v unrar &> /dev/null; then
                    cmd=("unrar" "x" "-inul")
                elif command -v rar &> /dev/null; then
                    cmd=("rar" "x" "-inul")
                else
                    echo -e "${RED}错误：unrar 或 rar 命令未安装！${NC}"
                    return
                fi
                ;;
            *.gz)
                if ! command -v gzip &> /dev/null; then
                    echo -e "${RED}错误：gzip 命令未安装！${NC}"
                    return
                fi
                # 对于单独的.gz文件，需要特殊处理
                if ! safe_read_confirm "解压.gz文件将覆盖原文件，是否继续" confirm; then
                    echo -e "${YELLOW}已取消${NC}"
                    return
                fi
                if [ "$confirm" != "y" ]; then
                    echo -e "${YELLOW}已取消${NC}"
                    return
                fi
                cmd=("gzip" "-d")
                ;;
            *.bz2)
                if ! command -v bzip2 &> /dev/null; then
                    echo -e "${RED}错误：bzip2 命令未安装！${NC}"
                    return
                fi
                if ! safe_read_confirm "解压.bz2文件将覆盖原文件，是否继续" confirm; then
                    echo -e "${YELLOW}已取消${NC}"
                    return
                fi
                if [ "$confirm" != "y" ]; then
                    echo -e "${YELLOW}已取消${NC}"
                    return
                fi
                cmd=("bzip2" "-d")
                ;;
            *.xz)
                if ! command -v xz &> /dev/null; then
                    echo -e "${RED}错误：xz 命令未安装！${NC}"
                    return
                fi
                if ! safe_read_confirm "解压.xz文件将覆盖原文件，是否继续" confirm; then
                    echo -e "${YELLOW}已取消${NC}"
                    return
                fi
                if [ "$confirm" != "y" ]; then
                    echo -e "${YELLOW}已取消${NC}"
                    return
                fi
                cmd=("xz" "-d")
                ;;
            *) 
                echo -e "${RED}不支持的压缩格式：$archive${NC}"
                return 
                ;;
        esac
        
        if ! safe_read "请输入解压目标目录（留空则当前目录）" dest "."; then
            return
        fi
        
        [[ -d $dest ]] || { echo -e "${YELLOW}目录不存在，将自动创建：${dest}${NC}"; mkdir -p "$dest"; }
        
        # 检查重复文件（仅对支持格式）
        echo -e "${YELLOW}检查重复文件中...${NC}"
        mapfile -t duplicates < <(check_duplicate_files "$archive" "$dest")
        
        if ((${#duplicates[@]} > 0)); then
            echo -e "${RED}发现以下重复文件：${NC}"
            for file in "${duplicates[@]}"; do
                echo -e "  ${RED}•${NC} $file"
            done
            
            while true; do
                echo -e "${YELLOW}请选择操作：${NC}"
                echo -e "  ${GREEN}1)${NC} 覆盖所有重复文件"
                echo -e "  ${GREEN}2)${NC} 跳过所有重复文件"
                echo -e "  ${GREEN}3)${NC} 逐个询问是否覆盖"
                echo -e "  ${GREEN}4)${NC} 取消解压"
                
                if ! safe_read_number "请选择 [1-4]" overwrite_choice 1 4; then
                    continue
                fi
                
                case $overwrite_choice in
                    1)
                        # 覆盖所有
                        case "$archive" in
                            *.zip) cmd=("unzip" "-o" "-q") ;;
                            *.7z) cmd=("7z" "x" "-y") ;;
                            *.rar) 
                                if [[ "${cmd[0]}" == "unrar" ]]; then
                                    cmd=("unrar" "x" "-o+" "-inul")
                                else
                                    cmd=("rar" "x" "-o+" "-inul")
                                fi
                                ;;
                            *.tar|*.tar.gz|*.tar.bz2|*.tar.xz|*.tgz|*.tbz2|*.txz) 
                                # tar 默认覆盖
                                ;;
                            *.gz|*.bz2|*.xz)
                                # 单文件压缩格式直接覆盖
                                ;;
                        esac
                        break
                        ;;
                    2)
                        # 跳过所有
                        case "$archive" in
                            *.zip) cmd=("unzip" "-n" "-q") ;;
                            *.7z|*.tar|*.tar.gz|*.tar.bz2|*.tar.xz|*.tgz|*.tbz2|*.txz|*.gz|*.bz2|*.xz) 
                                echo -e "${YELLOW}注意：此格式不支持跳过重复文件，将取消解压${NC}"
                                return
                                ;;
                            *.rar)
                                if [[ "${cmd[0]}" == "unrar" ]]; then
                                    cmd=("unrar" "x" "-o-" "-inul")
                                else
                                    cmd=("rar" "x" "-o-" "-inul")
                                fi
                                ;;
                        esac
                        break
                        ;;
                    3)
                        # 逐个询问
                        for file in "${duplicates[@]}"; do
                            while true; do
                                if ! safe_read_confirm "是否覆盖文件 '$file'" answer; then
                                    continue
                                fi
                                case $answer in
                                    y)
                                        # 对于不支持跳过单个文件的格式，需要手动删除
                                        if [[ "$archive" == *.tar.gz || "$archive" == *.tar.xz || "$archive" == *.tar.bz2 || "$archive" == *.tar || "$archive" == *.7z ]]; then
                                            rm -f "$dest/$file"
                                        fi
                                        break
                                        ;;
                                    n)
                                        # 对于 zip，设置跳过此文件
                                        if [[ "$archive" == *.zip ]]; then
                                            exclude_file=$(mktemp)
                                            echo "$file" > "$exclude_file"
                                            cmd=("unzip" "-q" "-x" "@$exclude_file")
                                        elif [[ "$archive" == *.rar ]]; then
                                            echo -e "${YELLOW}注意：rar 格式不支持排除单个文件，将跳过所有重复文件${NC}"
                                            if [[ "${cmd[0]}" == "unrar" ]]; then
                                                cmd=("unrar" "x" "-o-" "-inul")
                                            else
                                                cmd=("rar" "x" "-o-" "-inul")
                                            fi
                                            break 2
                                        else
                                            echo -e "${YELLOW}注意：此格式不支持排除单个文件，将取消解压${NC}"
                                            return
                                        fi
                                        break
                                        ;;
                                    *)
                                        echo -e "${RED}请输入 y 或 n${NC}"
                                        ;;
                                esac
                            done
                        done
                        break
                        ;;
                    4)
                        echo -e "${YELLOW}已取消解压${NC}"
                        return
                        ;;
                    *)
                        echo -e "${RED}无效选择，请重试${NC}"
                        ;;
                esac
            done
        fi
        
        echo -e "${GREEN}正在解压 → ${dest}${NC}"
        
        # 执行解压命令
        local result=0
        case "$archive" in
            *.zip)
                if [[ "${cmd[1]}" == "-x" ]]; then
                    "${cmd[@]}" "$archive" -d "$dest"
                    rm -f "$exclude_file" 2>/dev/null || true
                else
                    "${cmd[@]}" "$archive" -d "$dest"
                fi
                result=$?
                ;;
            *.7z)
                "${cmd[@]}" "$archive" -o"$dest"
                result=$?
                ;;
            *.tar|*.tar.gz|*.tar.bz2|*.tar.xz|*.tgz|*.tbz2|*.txz)
                "${cmd[@]}" "$archive" -C "$dest"
                result=$?
                ;;
            *.rar)
                "${cmd[@]}" "$archive" "$dest"/ 2>/dev/null || "${cmd[@]}" "$archive" "$dest"
                result=$?
                ;;
            *.gz|*.bz2|*.xz)
                # 单文件压缩格式，直接解压到当前目录
                "${cmd[@]}" "$archive"
                result=$?
                ;;
        esac
        
        if [[ $result -eq 0 ]]; then
            echo -e "${GREEN}解压完成！${NC}"
        else
            echo -e "${RED}解压失败！${NC}"
        fi
        
        if ! safe_read_confirm "是否继续解压其他文件" continue_decompress; then
            break
        fi
        if [ "$continue_decompress" != "y" ]; then
            break
        fi
    done
}

# 主程序
main() {
    # 获取默认菜单
    local default_menu=$(get_default_menu)
    local ip=$(get_internal_ip)
    
    # 显示欢迎信息
    clear
    echo -e "${GREEN}"
    echo "========================================"
    echo "         Linux 常用命令工具"
    echo "========================================"
    echo -e "${NC}"
    echo -e "${BLUE}检测到内网IP: ${ip}${NC}"
    echo -e "${YELLOW}当前工作目录: $(pwd)${NC}"
    
    case "$default_menu" in
        "pve") 
            echo -e "${YELLOW}根据IP地址，自动进入 PVE 命令合集${NC}"
            echo "----------------------------------------"
            echo -e "${CYAN}2秒后自动进入 PVE 菜单...${NC}"
            echo -e "${CYAN}按任意键跳过等待并选择菜单${NC}"
            echo "========================================"
            
            # 等待2秒，如果用户按键则进入主菜单
            if read -t 2 -n 1; then
                echo -e "\n${YELLOW}跳过自动选择，进入主菜单${NC}"
                sleep 1
                show_main_menu_loop
            else
                show_pve_menu
                show_main_menu_loop
            fi
            ;;
        "docker")
            echo -e "${YELLOW}根据IP地址，自动进入 FnOS 命令合集${NC}"
            echo "----------------------------------------"
            echo -e "${CYAN}2秒后自动进入 Docker 菜单...${NC}"
            echo -e "${CYAN}按任意键跳过等待并选择菜单${NC}"
            echo "========================================"
            
            # 等待2秒，如果用户按键则进入主菜单
            if read -t 2 -n 1; then
                echo -e "\n${YELLOW}跳过自动选择，进入主菜单${NC}"
                sleep 1
                show_main_menu_loop
            else
                show_docker_menu
                show_main_menu_loop
            fi
            ;;
        "nginx")
            echo -e "${YELLOW}根据IP地址，自动进入 Nginx 命令合集${NC}"
            echo "----------------------------------------"
            echo -e "${CYAN}2秒后自动进入 Nginx 菜单...${NC}"
            echo -e "${CYAN}按任意键跳过等待并选择菜单${NC}"
            echo "========================================"
            
            # 等待2秒，如果用户按键则进入主菜单
            if read -t 2 -n 1; then
                echo -e "\n${YELLOW}跳过自动选择，进入主菜单${NC}"
                sleep 1
                show_main_menu_loop
            else
                show_nginx_menu
                show_main_menu_loop
            fi
            ;;
        *)
            echo -e "${YELLOW}未识别到特定系统，进入主菜单${NC}"
            echo "========================================"
            show_main_menu_loop
            ;;
    esac
}

# 函数：显示主菜单循环
show_main_menu_loop() {
    while true; do
        show_main_menu
        
        if ! safe_read_number "请输入选择" main_choice 0 6; then
            continue
        fi
        
        case $main_choice in
            1)
                show_pve_menu
                ;;
            2)
                show_docker_menu
                ;;
            3)
                show_nginx_menu
                ;;
            4)
                show_linux_menu
                ;;
            5)
                show_linux_file_menu
                ;;
            6)
                show_compress_menu
                ;;
            0)
                echo -e "${GREEN}感谢使用，再见！${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}无效的选择，请重新输入${NC}"
                sleep 1
                ;;
        esac
    done
}

# 运行主程序
main